<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Interactive Sentiment Coder — CSV (doc_id + text)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #f7f8fa; --paper: #ffffff; --ink: #1f2937; --muted: #6b7280; --line: #e5e7eb;
      --accent: #2563eb; --accent-2: #f59e0b; --ok: #16a34a; --bad: #dc2626;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Roboto', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--ink); font-size: 14px; }
    .topbar { position: sticky; top: 0; z-index: 50; background: var(--paper); border-bottom: 1px solid var(--line);
      padding: 6px 10px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .brand { font-weight: 700; font-size: 14px; margin-right: 6px; }
    .muted { color: var(--muted); }
    .wrap { max-width: 1400px; margin: 12px auto; padding: 0 10px; }
    .panel { background: var(--paper); border: 1px solid var(--line); border-radius: 10px; padding: 10px; }
    .controls { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
    .stats { margin-left: auto; display: flex; gap: 8px; align-items: center; }
    .guide { background: #f8fafc; border: 1px solid var(--line); border-radius: 10px; padding: 10px; margin-top: 8px; font-size: 13px; }
    .guide h3 { margin: 0 0 6px 0; font-size: 15px; }
    .table thead th { position: sticky; top: 0; background: var(--paper); z-index: 5; font-size: 12.5px; }
    .table tbody td { font-size: 13px; }
    .table-responsive { max-height: calc(100vh - 180px); overflow: auto; }
    .row-focus { outline: 2px solid var(--accent); }
    .notif { position: fixed; right: 16px; bottom: 16px; background: #0ea5e9; color: #fff; padding: 10px 12px; border-radius: 8px; display: none; box-shadow: 0 8px 24px rgba(0,0,0,0.14); }
    .notif.error { background: var(--bad); }
    .badge-pill { border-radius: 999px; padding: 4px 10px; font-weight: 600; }
  .label-select { min-width: 220px; font-size: 13px; }
    .sticky-footer { position: sticky; bottom: 0; background: var(--paper); border-top: 1px solid var(--line); padding: 8px; display: flex; gap: 8px; }
    .search-wrap { display:flex; gap:6px; align-items:center }
    .tiny { font-size: 12px; }
    .progress { height: 8px; }
    .progress-label { font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">Interactive Sentiment Coder</div>
    <div class="controls">
      <input type="file" id="csvFile" accept=".csv" class="form-control" style="width:260px" />
  <button id="btnSaveNow" class="btn btn-success" disabled>Save Now</button>
  <button id="btnExportCsv" class="btn btn-primary" disabled>Export Labeled CSV</button>
      <button id="btnClearLabels" class="btn btn-outline-secondary" disabled>Clear Labels</button>
  <button id="btnClearProject" class="btn btn-outline-secondary" disabled>Clear Project</button>
      <div class="vr"></div>
      <div class="search-wrap">
        <input id="searchBox" type="search" class="form-control" placeholder="Search text or doc_id" style="width:260px" />
        <!-- Replaced checkbox with a 3-mode filter -->
        <select id="filterMode" class="form-select" style="width:180px">
          <option value="all">Show: All</option>
          <option value="unlabeled" selected>Show: Unlabeled</option>
          <option value="labeled">Show: Labeled</option>
        </select>
      </div>
      <div class="vr"></div>
      <button id="btnPrev" class="btn btn-outline-secondary" disabled>&larr; Prev</button>
      <button id="btnNext" class="btn btn-outline-secondary" disabled>Next &rarr;</button>
      <button id="btnNextUnlabeled" class="btn btn-outline-secondary" disabled>Next Unlabeled</button>
      <div class="vr"></div>
      <!-- Import labeled CSV to merge or load -->
      <input type="file" id="importLabeledFile" accept=".csv" style="display:none" />
      <button id="btnImportLabeled" class="btn btn-outline-secondary" disabled>Import Labeled CSV</button>
    </div>
    <div class="stats">
      <span id="datasetName" class="muted"></span>
      <span class="badge bg-light text-dark">Rows: <span id="statTotal">0</span></span>
      <span class="badge bg-success">Labeled: <span id="statLabeled">0</span></span>
    </div>
  </div>

  <div id="restorePrompt" class="alert alert-info py-2 px-3 m-2 d-none" role="alert" style="border-radius:10px;">
    <div class="d-flex justify-content-between align-items-center">
      <div class="tiny"><strong>Restore session?</strong> A saved project was found in browser storage. You can restore it or discard.</div>
      <div class="d-flex gap-2">
        <button id="btnRestore" class="btn btn-sm btn-primary">Restore</button>
        <button id="btnDiscard" class="btn btn-sm btn-outline-secondary">Discard</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="panel">
      <details>
        <summary class="fw-bold">Label Guide</summary>
        <div class="guide">
          <h3>How to label sentiment</h3>
          <div id="guideDefinitions" class="mb-2"></div>
          <div class="d-flex gap-2 mb-2">
            <button id="btnEditGuide" class="btn btn-sm btn-outline-secondary">Edit Guide</button>
            <button id="btnResetGuide" class="btn btn-sm btn-outline-danger">Reset Guide</button>
          </div>
          <div id="guideEditor" class="border rounded p-2 d-none">
            <div class="row g-2">
              <div class="col-12 col-md-6">
                <label class="form-label tiny mb-1"><strong>Highly Positive (3)</strong></label>
                <textarea id="guide_hp" class="form-control form-control-sm" rows="2"></textarea>
              </div>
              <div class="col-12 col-md-6">
                <label class="form-label tiny mb-1"><strong>Descriptive-Positive (2)</strong></label>
                <textarea id="guide_dp" class="form-control form-control-sm" rows="2"></textarea>
              </div>
              <div class="col-12 col-md-6">
                <label class="form-label tiny mb-1"><strong>Major Positive - Minor Negative (1)</strong></label>
                <textarea id="guide_mp" class="form-control form-control-sm" rows="2"></textarea>
              </div>
              <div class="col-12 col-md-6">
                <label class="form-label tiny mb-1"><strong>Descriptive/Neutral (0)</strong></label>
                <textarea id="guide_neu" class="form-control form-control-sm" rows="2"></textarea>
              </div>
              <div class="col-12 col-md-6">
                <label class="form-label tiny mb-1"><strong>Major Negative - Minor Positive (-1)</strong></label>
                <textarea id="guide_mn" class="form-control form-control-sm" rows="2"></textarea>
              </div>
              <div class="col-12 col-md-6">
                <label class="form-label tiny mb-1"><strong>Descriptive-Negative (-2)</strong></label>
                <textarea id="guide_dn" class="form-control form-control-sm" rows="2"></textarea>
              </div>
              <div class="col-12">
                <label class="form-label tiny mb-1"><strong>Highly Negative (-3)</strong></label>
                <textarea id="guide_hn" class="form-control form-control-sm" rows="2"></textarea>
              </div>
            </div>
            <div class="d-flex gap-2 mt-2">
              <button id="btnGuideSave" class="btn btn-sm btn-primary">Save Guide</button>
              <button id="btnGuideCancel" class="btn btn-sm btn-outline-secondary">Cancel</button>
            </div>
          </div>
          <div class="text-muted">
            Tips: Use 1–7 keys to assign labels to the focused row (1=Highly Positive … 7=Highly Negative). Use ↑/↓ to change focus; Enter moves to the next row; U clears the label.
          </div>
        </div>
      </details>

      <div class="table-responsive mt-2">
        <table class="table table-sm align-middle">
          <thead>
            <tr>
              <th style="width:120px">doc_id</th>
              <th>text (Main_Text/raw_text)</th>
              <th style="width:200px">sentiment</th>
            </tr>
          </thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>

      <div class="sticky-footer">
        <div class="me-auto small text-muted">Keyboard: 1..7 label, U clear, ↑/↓ focus, Enter next, Ctrl+F search.</div>
        <div>
          <button id="btnScrollTop" class="btn btn-outline-secondary btn-sm">Scroll Top</button>
          <button id="btnScrollBottom" class="btn btn-outline-secondary btn-sm">Scroll Bottom</button>
        </div>
      </div>
    </div>
  </div>

  <div id="notif" class="notif" role="status"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // ===== State & elements =====
    let rows = [];
    let textFieldName = null;
    let datasetKey = null;
    let filteredIdx = [];
    let focusIdx = -1;
    let fileName = '';
    let autoSaveTimer = null;
    const AUTO_SAVE_DELAY = 600; // ms

    // IndexedDB persistence (mirrors parent concept)
    const DB_NAME = 'sentiment_coder_db_v1';
    const DB_STORE = 'projects';
    const DB_KEY = 'current_project';
    let db = null;
    // Label guide state (7-point scale -3..3)
    let labelGuide = {
      'Highly Positive (3)': 'The review is strongly and consistently positive. Multiple strong positive expressions, recommendations, or emotive praise. No meaningful complaints/caveats. Example: “Absolutely amazing — must visit, best food and service ever!”',
      'Descriptive-Positive (2)': 'The review is mostly descriptive/factual, but contains minor positive sentiment (one or two mild positives). No negative tilt. Example: “It’s a long pedestrian street with many cafes. Nice place to sit in the evening.”',
  'Major Positive - Minor Negative (1)': 'Majority of the review is positive (many positive sentences or a clear positive tilt), but it can contain minor negative points (e.g., “a bit pricey”, “crowded sometimes”). Positives still dominate. Example: “Lovely market and food, though slightly expensive.”',
      'Descriptive/Neutral (0)': 'Purely descriptive / factual. No evaluative language or emotional qualifiers. Example: “Open 9–7, pedestrian-only street lined with shops.”',
  'Major Negative - Minor Positive (-1)': 'Overall negative tone; small or moderate positives may be present but criticism outweighs positives. Example: “Nice location, but too dirty and poor service.”',
      'Descriptive-Negative (-2)': 'The review is mostly descriptive, but contains minor negative sentiment (few negative sentences, no major praise). Not strongly emotional but has a clear negative tilt. Example: “Many shops here. Some are overpriced and small crowds are rude.”',
      'Highly Negative (-3)': 'Strong, consistent negative language throughout; strongly critical with no meaningful positives. Example: “Terrible experience — filthy, overpriced and rude staff. Avoid.”'
    };

    const DEFAULT_GUIDE = { ...labelGuide };

    const LABELS = [
      'Highly Positive (3)',
      'Descriptive-Positive (2)',
  'Major Positive - Minor Negative (1)',
      'Descriptive/Neutral (0)',
  'Major Negative - Minor Positive (-1)',
      'Descriptive-Negative (-2)',
      'Highly Negative (-3)'
    ];

    // Backward compatibility for older 5-point labels
    const LEGACY_LABEL_MAP = {
      'Totally Positive': 'Highly Positive (3)',
  'Mostly Positive': 'Major Positive - Minor Negative (1)',
      'Neutral': 'Descriptive/Neutral (0)',
  'Mostly Negative': 'Major Negative - Minor Positive (-1)',
      'Totally Negative': 'Highly Negative (-3)'
    };
    function normalizeLabel(lab){
      if(!lab) return '';
      const mapped = LEGACY_LABEL_MAP[lab] || lab;
      // If still not one of current labels, keep as-is so export preserves it
      return LABELS.includes(mapped) ? mapped : mapped;
    }

    const els = {
      csvFile: document.getElementById('csvFile'),
      btnExportCsv: document.getElementById('btnExportCsv'),
      btnClearLabels: document.getElementById('btnClearLabels'),
      btnPrev: document.getElementById('btnPrev'),
      btnNext: document.getElementById('btnNext'),
      btnNextUnlabeled: document.getElementById('btnNextUnlabeled'),
      searchBox: document.getElementById('searchBox'),
      filterMode: document.getElementById('filterMode'),
      dataBody: document.getElementById('dataBody'),
      datasetName: document.getElementById('datasetName'),
      statTotal: document.getElementById('statTotal'),
      statLabeled: document.getElementById('statLabeled'),
      notif: document.getElementById('notif'),
      btnScrollTop: document.getElementById('btnScrollTop'),
      btnScrollBottom: document.getElementById('btnScrollBottom'),
      btnImportLabeled: document.getElementById('btnImportLabeled'),
      importLabeledFile: document.getElementById('importLabeledFile'),
      btnSaveNow: document.getElementById('btnSaveNow'),
      btnClearProject: document.getElementById('btnClearProject'),
      restorePrompt: document.getElementById('restorePrompt'),
      btnRestore: document.getElementById('btnRestore'),
      btnDiscard: document.getElementById('btnDiscard'),
      // Guide UI
      guideDefinitions: document.getElementById('guideDefinitions'),
      guideEditor: document.getElementById('guideEditor'),
      btnEditGuide: document.getElementById('btnEditGuide'),
      btnResetGuide: document.getElementById('btnResetGuide'),
      btnGuideSave: document.getElementById('btnGuideSave'),
      btnGuideCancel: document.getElementById('btnGuideCancel'),
      g_hp: document.getElementById('guide_hp'),
      g_dp: document.getElementById('guide_dp'),
      g_mp: document.getElementById('guide_mp'),
      g_neu: document.getElementById('guide_neu'),
      g_mn: document.getElementById('guide_mn'),
      g_dn: document.getElementById('guide_dn'),
      g_hn: document.getElementById('guide_hn'),
    };

    function notify(msg, kind='info', timeout=1800){
      els.notif.textContent = msg;
      els.notif.className = 'notif' + (kind === 'error' ? ' error' : '');
      els.notif.style.display = 'block';
      if(timeout) setTimeout(()=> els.notif.style.display='none', timeout);
    }
    function djb2(str){ let h=5381; for(let i=0;i<str.length;i++){ h=((h<<5)+h)+str.charCodeAt(i); h|=0; } return (h>>>0).toString(36); }
    function buildDatasetKey(filename, ids){ const sig = filename+'|'+ids.slice(0,200).join('|')+'|'+ids.length; return 'sentiment_labels::'+djb2(sig); }
  function saveLabels(){ if(!datasetKey) return; const map = Object.fromEntries(rows.map(r=>[String(r.doc_id), r.label || ''])); localStorage.setItem(datasetKey, JSON.stringify(map)); }
  function tryRestoreLabels(){ if(!datasetKey) return 0; const txt = localStorage.getItem(datasetKey); if(!txt) return 0; try{ const map=JSON.parse(txt); let n=0; rows.forEach(r=>{ const k=String(r.doc_id); if(map[k]){ r.label=normalizeLabel(map[k]); n++; } }); return n; }catch(e){ return 0; } }

    function detectTextField(fields){
      const candidates=['Main_Text','raw_text','text','review_text','MainText','RawText'];
      for(const c of candidates){ if(fields.includes(c)) return c; }
      const lower=fields.map(f=>f.toLowerCase());
      for(const o of ['main_text','raw_text','text']){ const i=lower.indexOf(o); if(i>=0) return fields[i]; }
      return null;
    }

    function updateStats(){ els.statTotal.textContent=rows.length; els.statLabeled.textContent=rows.filter(r=>r.label && r.label.trim()).length; }

    function applyFilters(){
      const q=(els.searchBox.value||'').trim().toLowerCase();
      const mode=(els.filterMode && els.filterMode.value)||'all';
      filteredIdx=[];
      for(let i=0;i<rows.length;i++){
        const r=rows[i];
        const hay=(String(r.doc_id)+' '+String(r.text||'')).toLowerCase();
        const passQ=q? hay.includes(q): true;
        let passF=true;
        if(mode==='unlabeled') passF=!(r.label && r.label.trim());
        else if(mode==='labeled') passF=!!(r.label && r.label.trim());
        if(passQ && passF) filteredIdx.push(i);
      }
      if(filteredIdx.length===0) focusIdx=-1; else if(focusIdx<0 || focusIdx>=filteredIdx.length) focusIdx=0;
    }

    function renderTable(){
      applyFilters();
      const frag=document.createDocumentFragment();
      for(const [k, idx] of filteredIdx.entries()){
        const r=rows[idx];
        const tr=document.createElement('tr'); tr.dataset.idx=String(idx);
        if(k===focusIdx) tr.classList.add('row-focus');
        const tdId=document.createElement('td'); tdId.textContent=String(r.doc_id); tdId.className='small text-muted'; tr.appendChild(tdId);
        const tdText=document.createElement('td'); tdText.textContent=String(r.text||'').trim(); tr.appendChild(tdText);
        const tdLabel=document.createElement('td');
        const sel=document.createElement('select'); sel.className='form-select form-select-sm label-select'; sel.dataset.idx=String(idx);
        const empty=document.createElement('option'); empty.value=''; empty.textContent='— Select sentiment —'; sel.appendChild(empty);
        for(let i=0;i<LABELS.length;i++){ const opt=document.createElement('option'); opt.value=LABELS[i]; opt.textContent=`${i+1}. ${LABELS[i]}`; sel.appendChild(opt); }
        sel.value=normalizeLabel(r.label) || '';
        tdLabel.appendChild(sel); tr.appendChild(tdLabel);
        frag.appendChild(tr);
      }
      els.dataBody.innerHTML=''; els.dataBody.appendChild(frag);
      const hasData=rows.length>0; els.btnExportCsv.disabled=!hasData; els.btnClearLabels.disabled=!hasData; els.btnPrev.disabled=!hasData; els.btnNext.disabled=!hasData; els.btnNextUnlabeled.disabled=!hasData; els.btnImportLabeled.disabled=!hasData; if(els.btnClearProject) els.btnClearProject.disabled=!hasData; updateStats();
    }

    function focusRowByFilteredIndex(k){ if(k<0 || k>=filteredIdx.length) return; focusIdx=k; document.querySelectorAll('#dataBody tr').forEach((tr,i)=>{ if(i===focusIdx) tr.classList.add('row-focus'); else tr.classList.remove('row-focus'); }); const tr=document.querySelector('#dataBody tr:nth-child('+(focusIdx+1)+')'); if(tr) tr.scrollIntoView({block:'nearest'}); }
    function labelFocusedRowByIndex(labelIndex){ if(focusIdx<0 || focusIdx>=filteredIdx.length) return; const realIdx=filteredIdx[focusIdx]; rows[realIdx].label=LABELS[labelIndex]; const rowEl=document.querySelector('#dataBody tr:nth-child('+(focusIdx+1)+') select'); if(rowEl) rowEl.value=LABELS[labelIndex]; saveLabels(); updateStats(); }
    function nextRow(){ if(focusIdx>=0 && focusIdx<filteredIdx.length-1) focusRowByFilteredIndex(focusIdx+1); }
    function prevRow(){ if(focusIdx>0) focusRowByFilteredIndex(focusIdx-1); }
    function nextUnlabeled(){ if(filteredIdx.length===0) return; const start=Math.max(0, focusIdx); for(let k=start;k<filteredIdx.length;k++){ const r=rows[filteredIdx[k]]; if(!r.label || !r.label.trim()){ focusRowByFilteredIndex(k); return; } } for(let k=0;k<start;k++){ const r=rows[filteredIdx[k]]; if(!r.label || !r.label.trim()){ focusRowByFilteredIndex(k); return; } } notify('No unlabeled rows in current filter'); }

    // IndexedDB helpers
    function openDB(){
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = function(evt){ const db = evt.target.result; if(!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE); };
        req.onsuccess = evt => { db = evt.target.result; resolve(db); };
        req.onerror = evt => reject(evt.target.error);
      });
    }
    function saveProjectToDB(){
      if(!db) return Promise.resolve();
      return new Promise((resolve,reject)=>{
        try{
          const tx = db.transaction([DB_STORE], 'readwrite');
          const store = tx.objectStore(DB_STORE);
          const payload = { fileName, textFieldName, rows, labelGuide, savedAt: new Date().toISOString() };
          const req = store.put(payload, DB_KEY);
          req.onsuccess = ()=> resolve();
          req.onerror = e => reject(e.target.error);
        }catch(e){ reject(e); }
      });
    }
    function loadProjectFromDB(){
      if(!db) return Promise.resolve(null);
      return new Promise((resolve,reject)=>{
        try{
          const tx = db.transaction([DB_STORE], 'readonly');
          const store = tx.objectStore(DB_STORE);
          const req = store.get(DB_KEY);
          req.onsuccess = ()=> resolve(req.result || null);
          req.onerror = e => reject(e.target.error);
        }catch(e){ reject(e); }
      });
    }
    function clearProjectFromDB(){
      if(!db) return Promise.resolve();
      return new Promise((resolve,reject)=>{
        try{
          const tx = db.transaction([DB_STORE], 'readwrite');
          const store = tx.objectStore(DB_STORE);
          const req = store.delete(DB_KEY);
          req.onsuccess = ()=> resolve();
          req.onerror = e => reject(e.target.error);
        }catch(e){ reject(e); }
      });
    }
  function scheduleAutoSave(){ if(autoSaveTimer) clearTimeout(autoSaveTimer); autoSaveTimer = setTimeout(()=>{ saveProjectToDB().catch(()=>{}); }, AUTO_SAVE_DELAY); }
  function setLoadedUIState(isLoaded){ if(els.btnClearProject) els.btnClearProject.disabled = !isLoaded; if(els.btnSaveNow) els.btnSaveNow.disabled = !isLoaded; }

    // ===== Guide rendering and editing =====
    function renderGuide(){
      if(!els.guideDefinitions) return;
      const order = LABELS; // use same label order
      const ul = document.createElement('ul'); ul.className = 'mb-2';
      order.forEach(lab=>{
        const li = document.createElement('li');
        const strong = document.createElement('strong'); strong.textContent = lab;
        li.appendChild(strong); li.appendChild(document.createTextNode(' — ' + (labelGuide[lab] || '')));
        ul.appendChild(li);
      });
      els.guideDefinitions.innerHTML=''; els.guideDefinitions.appendChild(ul);
    }
    function openGuideEditor(){ if(!els.guideEditor) return; els.guideEditor.classList.remove('d-none');
      els.g_hp.value = labelGuide['Highly Positive (3)'] || '';
      els.g_dp.value = labelGuide['Descriptive-Positive (2)'] || '';
  els.g_mp.value = labelGuide['Major Positive - Minor Negative (1)'] || '';
      els.g_neu.value = labelGuide['Descriptive/Neutral (0)'] || '';
  els.g_mn.value = labelGuide['Major Negative - Minor Positive (-1)'] || '';
      els.g_dn.value = labelGuide['Descriptive-Negative (-2)'] || '';
      els.g_hn.value = labelGuide['Highly Negative (-3)'] || '';
    }
    function closeGuideEditor(){ if(!els.guideEditor) return; els.guideEditor.classList.add('d-none'); }
    function ensureGuideKeys(){
      // Ensure all current LABELS have definitions; if missing, use defaults or empty
      LABELS.forEach(k=>{
        if(!(k in labelGuide)) labelGuide[k] = DEFAULT_GUIDE[k] || '';
      });
    }
    function resetGuideToDefaults(){
      labelGuide = {
        'Highly Positive (3)': 'The review is strongly and consistently positive. Multiple strong positive expressions, recommendations, or emotive praise. No meaningful complaints/caveats. Example: “Absolutely amazing — must visit, best food and service ever!”',
        'Descriptive-Positive (2)': 'The review is mostly descriptive/factual, but contains minor positive sentiment (one or two mild positives). No negative tilt. Example: “It’s a long pedestrian street with many cafes. Nice place to sit in the evening.”',
  'Major Positive - Minor Negative (1)': 'Majority of the review is positive (many positive sentences or a clear positive tilt), but it can contain minor negative points (e.g., “a bit pricey”, “crowded sometimes”). Positives still dominate. Example: “Lovely market and food, though slightly expensive.”',
        'Descriptive/Neutral (0)': 'Purely descriptive / factual. No evaluative language or emotional qualifiers. Example: “Open 9–7, pedestrian-only street lined with shops.”',
  'Major Negative - Minor Positive (-1)': 'Overall negative tone; small or moderate positives may be present but criticism outweighs positives. Example: “Nice location, but too dirty and poor service.”',
        'Descriptive-Negative (-2)': 'The review is mostly descriptive, but contains minor negative sentiment (few negative sentences, no major praise). Not strongly emotional but has a clear negative tilt. Example: “Many shops here. Some are overpriced and small crowds are rude.”',
        'Highly Negative (-3)': 'Strong, consistent negative language throughout; strongly critical with no meaningful positives. Example: “Terrible experience — filthy, overpriced and rude staff. Avoid.”'
      };
      ensureGuideKeys();
      renderGuide(); scheduleAutoSave();
    }
    if(els.btnEditGuide) els.btnEditGuide.addEventListener('click', ()=> openGuideEditor());
    if(els.btnGuideCancel) els.btnGuideCancel.addEventListener('click', ()=> closeGuideEditor());
    if(els.btnGuideSave) els.btnGuideSave.addEventListener('click', ()=>{
      labelGuide['Highly Positive (3)'] = els.g_hp.value.trim();
      labelGuide['Descriptive-Positive (2)'] = els.g_dp.value.trim();
      labelGuide['Major Positive - Minor Negative (1)'] = els.g_mp.value.trim();
      labelGuide['Descriptive/Neutral (0)'] = els.g_neu.value.trim();
      labelGuide['Major Negative - Minor Positive (-1)'] = els.g_mn.value.trim();
      labelGuide['Descriptive-Negative (-2)'] = els.g_dn.value.trim();
      labelGuide['Highly Negative (-3)'] = els.g_hn.value.trim();
      renderGuide();
      closeGuideEditor();
      // Keep the guide panel open and scroll into view so changes are visible
      const guidePanel = document.querySelector('details');
      if(guidePanel){ guidePanel.open = true; }
      if(els.guideDefinitions){ els.guideDefinitions.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
      scheduleAutoSave();
      notify('Guide updated');
    });
    if(els.btnResetGuide) els.btnResetGuide.addEventListener('click', ()=>{ if(confirm('Reset guide definitions to defaults?')) resetGuideToDefaults(); });

  // Render guide once on startup so defaults are visible even before loading/restoring a dataset
  renderGuide();

    // Import CSV
    els.csvFile.addEventListener('change', (e)=>{
      const file=e.target.files && e.target.files[0]; if(!file) return;
      Papa.parse(file, { header:true, skipEmptyLines:'greedy', complete: function(res){
        const data=res.data||[]; const fields=res.meta && res.meta.fields? res.meta.fields: Object.keys(data[0]||{});
        const textField=detectTextField(fields);
        if(!fields.includes('doc_id') || !textField){ notify('CSV must include doc_id and Main_Text/raw_text columns','error', 3500); return; }
  textFieldName=textField; fileName = file.name;
  rows=data.map((row,i)=>({ doc_id: row['doc_id'] ?? (row['id'] ?? (i+1)), text: row[textFieldName] ?? '', label: '' }));
        datasetKey=buildDatasetKey(file.name, rows.map(r=>String(r.doc_id)));
        const restored=tryRestoreLabels();
        els.datasetName.textContent=file.name + (restored? ` — restored ${restored} labels`: '');
        if(els.filterMode) els.filterMode.value='unlabeled';
        focusIdx=0; renderTable(); notify('CSV loaded');
        // Save to DB immediately and enable Clear Project
        renderGuide();
        saveProjectToDB().then(()=> setLoadedUIState(true)).catch(()=>{});
      }, error: function(){ notify('Failed to parse CSV','error'); }});
    });

    // Edit label via select
    els.dataBody.addEventListener('change', (e)=>{
      const t=e.target; if(t && t.matches('select.label-select')){
        const idx=Number(t.dataset.idx);
        rows[idx].label=t.value || '';
        saveLabels(); updateStats();
        // Immediate save and update view according to filter
        saveProjectToDB().catch(()=>{});
        if(els.filterMode && els.filterMode.value === 'unlabeled'){
          // Remove labeled row from current view and jump to next unlabeled
          renderTable();
          nextUnlabeled();
        }
      }
    });

    // Row focus via click
    els.dataBody.addEventListener('click', (e)=>{ const tr=e.target.closest('tr'); if(!tr) return; const all=Array.from(els.dataBody.querySelectorAll('tr')); const k=all.indexOf(tr); focusRowByFilteredIndex(k); });

    // Navigation
    els.btnPrev.addEventListener('click', prevRow);
    els.btnNext.addEventListener('click', nextRow);
    els.btnNextUnlabeled.addEventListener('click', nextUnlabeled);

    // Export CSV
    els.btnExportCsv.addEventListener('click', ()=>{
  if(rows.length===0) return; const header=['doc_id', textFieldName, 'sentiment_label'];
      const data=rows.map(r=>({ 'doc_id': r.doc_id, [textFieldName]: r.text, 'sentiment_label': r.label || '' }));
      const csv=Papa.unparse({ fields: header, data: data.map(row=> header.map(h=> row[h])) });
      const blob=new Blob([csv], { type:'text/csv;charset=utf-8;' }); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='sentiment_labeled.csv'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); notify('Exported labeled CSV');
      // Optional: ask to clear project after export
      setTimeout(async ()=>{
        try{
          if(confirm('Export complete. Clear saved project from this browser?')){
            await clearProjectFromDB(); setLoadedUIState(false); notify('Project cleared from browser storage');
          }
        }catch(_){}
      }, 200);
    });

    // Manual Save Now
    if(els.btnSaveNow){ els.btnSaveNow.addEventListener('click', async ()=>{ try{ await saveProjectToDB(); notify('Saved to browser storage'); }catch(e){ notify('Save failed','error'); } }); }

    // Filter & scroll controls
    els.searchBox.addEventListener('input', ()=>{ renderTable(); });
    if(els.filterMode) els.filterMode.addEventListener('change', ()=>{ renderTable(); });
    els.btnScrollTop.addEventListener('click', ()=>{ const wrap=document.querySelector('.table-responsive'); if(wrap) wrap.scrollTo({top:0, behavior:'smooth'}); });
    els.btnScrollBottom.addEventListener('click', ()=>{ const wrap=document.querySelector('.table-responsive'); if(wrap) wrap.scrollTo({top:999999, behavior:'smooth'}); });

    // Import labeled CSV (merge or load)
    els.btnImportLabeled.addEventListener('click', ()=>{ els.importLabeledFile.click(); });
    els.importLabeledFile.addEventListener('change', (e)=>{
      const file=e.target.files && e.target.files[0]; if(!file) return;
      Papa.parse(file, { header:true, skipEmptyLines:'greedy', complete: function(res){
        const data=res.data||[]; if(!data.length){ notify('No rows found in labeled CSV','error'); return; }
        const fields=res.meta && res.meta.fields? res.meta.fields: Object.keys(data[0]||{});
        const textField=detectTextField(fields);
        const hasSent=fields.includes('sentiment_label');
        if(!fields.includes('doc_id') || !hasSent){ notify('Labeled CSV must include doc_id and sentiment_label','error', 4000); return; }
        let updated=0, skipped=0;
        if(rows.length){
          const byId=new Map(rows.map((r,i)=>[String(r.doc_id), i]));
          data.forEach(row=>{ const id=String(row['doc_id']); if(byId.has(id)){ const idx=byId.get(id); rows[idx].label=normalizeLabel(row['sentiment_label'] || ''); if(textField && row[textField] && !rows[idx].text){ rows[idx].text=row[textField]; } updated++; } else { skipped++; } });
          saveLabels(); updateStats(); renderTable(); scheduleAutoSave(); notify(`Imported labels: updated ${updated}` + (skipped? `, skipped ${skipped}`: ''));
        } else {
          if(!textField){ notify('Cannot load labeled CSV as dataset: missing text column','error'); return; }
          textFieldName=textField;
          rows=data.map((row,i)=>({ doc_id: row['doc_id'] ?? (row['id'] ?? (i+1)), text: row[textFieldName] ?? '', label: normalizeLabel(row['sentiment_label'] || '') }));
          datasetKey=buildDatasetKey(file.name, rows.map(r=>String(r.doc_id)));
          els.datasetName.textContent=file.name + ' (labeled import)';
          fileName = file.name; focusIdx=0; renderTable(); renderGuide(); saveProjectToDB().then(()=> setLoadedUIState(true)).catch(()=>{}); notify('Loaded labeled dataset');
        }
        e.target.value='';
      }, error: function(){ notify('Failed to parse labeled CSV','error'); }});
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      if(rows.length===0) return; const tag=(e.target && e.target.tagName || '').toLowerCase(); if(tag==='input' || tag==='select' || tag==='textarea') return;
      if(e.key==='ArrowDown'){ e.preventDefault(); nextRow(); return; }
      if(e.key==='ArrowUp'){ e.preventDefault(); prevRow(); return; }
      if(e.key==='Enter'){ e.preventDefault(); nextRow(); return; }
      if(e.key==='u' || e.key==='U'){
        e.preventDefault();
        if(focusIdx>=0){
          const realIdx=filteredIdx[focusIdx];
          rows[realIdx].label='';
          const sel=document.querySelector('#dataBody tr:nth-child('+(focusIdx+1)+') select'); if(sel) sel.value='';
          saveLabels(); updateStats(); saveProjectToDB().catch(()=>{});
          // If viewing labeled only, removing label should hide it
          if(els.filterMode && els.filterMode.value === 'labeled'){
            renderTable();
            // Move to next labeled if available
            nextRow();
          }
        }
        return;
      }
      const num=Number(e.key);
      if(num>=1 && num<=7){
        e.preventDefault();
        labelFocusedRowByIndex(num-1);
        saveProjectToDB().catch(()=>{});
        if(els.filterMode && els.filterMode.value === 'unlabeled'){
          renderTable();
          nextUnlabeled();
        } else {
          nextRow();
        }
      }
    });

    // Clear Project button
    if(els.btnClearProject){ els.btnClearProject.addEventListener('click', async ()=>{ if(confirm('Clear current project from browser storage and reset the session?')){ await clearProjectFromDB(); rows=[]; textFieldName=null; datasetKey=null; fileName=''; filteredIdx=[]; focusIdx=-1; els.dataBody.innerHTML=''; els.datasetName.textContent=''; updateStats(); setLoadedUIState(false); notify('Project cleared'); } }); }

    // Startup: open DB and ask to restore
    (async function init(){
      try{
        await openDB();
        const proj = await loadProjectFromDB();
        if(proj && proj.rows && proj.rows.length){
          // show restore banner
          if(els.restorePrompt) els.restorePrompt.classList.remove('d-none');
          if(els.btnRestore) els.btnRestore.onclick = ()=>{
            rows = (proj.rows || []).map(r=> ({...r, label: normalizeLabel(r.label)})); textFieldName = proj.textFieldName; fileName = proj.fileName || '';
            if(proj.labelGuide) labelGuide = proj.labelGuide;
            ensureGuideKeys();
            els.datasetName.textContent = fileName ? `${fileName} — restored session` : 'restored session';
            if(els.restorePrompt) els.restorePrompt.classList.add('d-none');
            renderTable(); renderGuide(); notify('Session restored'); setLoadedUIState(true);
          };
          if(els.btnDiscard) els.btnDiscard.onclick = async ()=>{
            await clearProjectFromDB(); if(els.restorePrompt) els.restorePrompt.classList.add('d-none'); setLoadedUIState(false); notify('Previous session discarded');
          };
        }
      }catch(e){ console.error('DB init error', e); }
    })();
  </script>
</body>
</html>