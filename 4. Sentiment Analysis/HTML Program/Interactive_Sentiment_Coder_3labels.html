<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Interactive Sentiment Coder — 3 Labels (Positive/Neutral/Negative)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #f7f8fa; --paper: #ffffff; --ink: #1f2937; --muted: #6b7280; --line: #e5e7eb;
      --accent: #2563eb; --accent-2: #f59e0b; --ok: #16a34a; --bad: #dc2626;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Roboto', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--ink); font-size: 14px; }
    .topbar { position: sticky; top: 0; z-index: 50; background: var(--paper); border-bottom: 1px solid var(--line);
      padding: 6px 10px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .brand { font-weight: 700; font-size: 14px; margin-right: 6px; }
    .muted { color: var(--muted); }
    .wrap { max-width: 1400px; margin: 12px auto; padding: 0 10px; }
    .panel { background: var(--paper); border: 1px solid var(--line); border-radius: 10px; padding: 10px; }
    .controls { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
    .stats { margin-left: auto; display: flex; gap: 8px; align-items: center; }
    .guide { background: #f8fafc; border: 1px solid var(--line); border-radius: 10px; padding: 10px; margin-top: 8px; font-size: 13px; }
    .guide h3 { margin: 0 0 6px 0; font-size: 15px; }
    .table thead th { position: sticky; top: 0; background: var(--paper); z-index: 5; font-size: 12.5px; }
    .table tbody td { font-size: 13px; }
    .table-responsive { max-height: calc(100vh - 220px); overflow: auto; }
    .row-focus { outline: 2px solid var(--accent); }
    .notif { position: fixed; right: 16px; bottom: 16px; background: #0ea5e9; color: #fff; padding: 10px 12px; border-radius: 8px; display: none; box-shadow: 0 8px 24px rgba(0,0,0,0.14); }
    .notif.error { background: var(--bad); }
    .badge-pill { border-radius: 999px; padding: 4px 10px; font-weight: 600; }
    .label-select { min-width: 200px; font-size: 13px; }
    .sticky-footer { position: sticky; bottom: 0; background: var(--paper); border-top: 1px solid var(--line); padding: 8px; display: flex; gap: 8px; }
    .search-wrap { display:flex; gap:6px; align-items:center }
    .tiny { font-size: 12px; }
    .progress { height: 8px; }
    .progress-label { font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">Interactive Sentiment Coder (3-label)</div>
    <div class="controls">
      <input type="file" id="csvFile" accept=".csv" class="form-control" style="width:260px" />
      <button id="btnSaveNow" class="btn btn-success" disabled>Save Now</button>
      <button id="btnExportCsv" class="btn btn-primary" disabled>Export Labeled CSV</button>
      <button id="btnClearLabels" class="btn btn-outline-secondary" disabled>Clear Labels</button>
      <button id="btnClearProject" class="btn btn-outline-secondary" disabled>Clear Project</button>
      <div class="vr"></div>
      <div class="search-wrap">
        <input id="searchBox" type="search" class="form-control" placeholder="Search text or doc_id" style="width:260px" />
        <select id="filterMode" class="form-select" style="width:160px">
          <option value="all" selected>Show: All</option>
          <option value="unlabeled">Show: Unlabeled</option>
          <option value="labeled">Show: Labeled</option>
        </select>
        <!-- New label filter -->
        <select id="labelFilter" class="form-select" style="width:180px" title="Filter by label">
          <option value="any" selected>Label: Any</option>
          <option value="Positive">Label: Positive</option>
          <option value="Neutral">Label: Neutral</option>
          <option value="Negative">Label: Negative</option>
        </select>
      </div>
      <div class="vr"></div>
      <button id="btnPrev" class="btn btn-outline-secondary" disabled>&larr; Prev</button>
      <button id="btnNext" class="btn btn-outline-secondary" disabled>Next &rarr;</button>
      <button id="btnNextUnlabeled" class="btn btn-outline-secondary" disabled>Next Unlabeled</button>
      <div class="vr"></div>
      <input type="file" id="importLabeledFile" accept=".csv" style="display:none" />
      <button id="btnImportLabeled" class="btn btn-outline-secondary" disabled>Import Labeled CSV</button>
    </div>
    <div class="stats">
      <span id="datasetName" class="muted"></span>
      <span class="badge bg-light text-dark">Rows: <span id="statTotal">0</span></span>
      <span class="badge bg-success">Labeled: <span id="statLabeled">0</span></span>
    </div>
  </div>

  <div id="restorePrompt" class="alert alert-info py-2 px-3 m-2 d-none" role="alert" style="border-radius:10px;">
    <div class="d-flex justify-content-between align-items-center">
      <div class="tiny"><strong>Restore session?</strong> A saved project was found in browser storage. You can restore it or discard.</div>
      <div class="d-flex gap-2">
        <button id="btnRestore" class="btn btn-sm btn-primary">Restore</button>
        <button id="btnDiscard" class="btn btn-sm btn-outline-secondary">Discard</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="panel">
      <details>
        <summary class="fw-bold">Label Guide</summary>
        <div class="guide">
          <h3>How to label sentiment (3 levels)</h3>
          <div id="guideDefinitions" class="mb-2"></div>
          <div class="d-flex gap-2 mb-2">
            <button id="btnEditGuide" class="btn btn-sm btn-outline-secondary">Edit Guide</button>
            <button id="btnResetGuide" class="btn btn-sm btn-outline-danger">Reset Guide</button>
          </div>
          <div id="guideEditor" class="border rounded p-2 d-none">
            <div class="row g-2">
              <div class="col-12 col-md-4">
                <label class="form-label tiny mb-1"><strong>Positive</strong></label>
                <textarea id="guide_pos" class="form-control form-control-sm" rows="3"></textarea>
              </div>
              <div class="col-12 col-md-4">
                <label class="form-label tiny mb-1"><strong>Neutral</strong></label>
                <textarea id="guide_neu" class="form-control form-control-sm" rows="3"></textarea>
              </div>
              <div class="col-12 col-md-4">
                <label class="form-label tiny mb-1"><strong>Negative</strong></label>
                <textarea id="guide_neg" class="form-control form-control-sm" rows="3"></textarea>
              </div>
            </div>
            <div class="d-flex gap-2 mt-2">
              <button id="btnGuideSave" class="btn btn-sm btn-primary">Save Guide</button>
              <button id="btnGuideCancel" class="btn btn-sm btn-outline-secondary">Cancel</button>
            </div>
          </div>
          <div class="text-muted">
            Tips: Use 1–3 keys to assign labels to the focused row (1=Positive, 2=Neutral, 3=Negative). Use ↑/↓ to change focus; Enter moves to the next row; U clears the label.
          </div>
        </div>
      </details>

      <div class="table-responsive mt-2">
        <table class="table table-sm align-middle">
          <thead>
            <tr>
              <th style="width:120px">doc_id</th>
              <th>text (Main_Text/raw_text)</th>
              <th style="width:200px">sentiment</th>
            </tr>
          </thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>

      <div class="sticky-footer">
        <div class="me-auto small text-muted">Keyboard: 1..3 label, U clear, ↑/↓ focus, Enter next, Ctrl+F search.</div>
        <div>
          <button id="btnScrollTop" class="btn btn-outline-secondary btn-sm">Scroll Top</button>
          <button id="btnScrollBottom" class="btn btn-outline-secondary btn-sm">Scroll Bottom</button>
        </div>
      </div>
    </div>
  </div>

  <div id="notif" class="notif" role="status"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // ===== State & elements =====
    let rows = [];
    let textFieldName = null;
    let labelColumnName = 'sentiment_label'; // prefer 'human_label' if found
    let hasSourceColumn = false; // track if 'source' exists in dataset
    let datasetKey = null;
    let filteredIdx = [];
    let focusIdx = -1;
    let fileName = '';
    let autoSaveTimer = null;
    const AUTO_SAVE_DELAY = 600; // ms

    // IndexedDB persistence
    const DB_NAME = 'sentiment_coder_3labels_db_v1';
    const DB_STORE = 'projects';
    const DB_KEY = 'current_project';
    let db = null;

    // Label guide (3-point)
    const LABELS = ['Positive', 'Neutral', 'Negative'];
    let labelGuide = {
      'Positive': 'Overall positive sentiment: praise, satisfaction, recommendations, positive emotions. Example: "Loved the ambience and service; would visit again."',
      'Neutral': 'Objective/neutral description without clear evaluation. Facts, details, or mixed content with no strong tilt. Example: "Pedestrian street with many shops, open till late."',
      'Negative': 'Overall negative sentiment: complaints, dissatisfaction, or criticism. Example: "Overpriced and crowded; staff was rude."'
    };
    const DEFAULT_GUIDE = { ...labelGuide };

    // Map legacy labels (7-point/5-point/variants) into 3 labels
    const LEGACY_TO_3 = {
      'Highly Positive (3)': 'Positive',
      'Descriptive-Positive (2)': 'Positive',
      'Major Positive - Minor Negative (1)': 'Positive',
      'Descriptive/Neutral (0)': 'Neutral',
      'Major Negative - Minor Positive (-1)': 'Negative',
      'Descriptive-Negative (-2)': 'Negative',
      'Highly Negative (-3)': 'Negative',
      'Totally Positive': 'Positive',
      'Mostly Positive': 'Positive',
      'Neutral': 'Neutral',
      'Mostly Negative': 'Negative',
      'Totally Negative': 'Negative',
      'positive': 'Positive',
      'neutral': 'Neutral',
      'negative': 'Negative',
      'pos': 'Positive',
      'neg': 'Negative',
      '3': 'Positive', '2': 'Positive', '1': 'Positive',
      '0': 'Neutral',
      '-1': 'Negative', '-2': 'Negative', '-3': 'Negative'
    };
    function normalizeLabel(lab){
      if(!lab) return '';
      const s = String(lab).trim();
      if(LABELS.includes(s)) return s;
      const key = s.toLowerCase();
      // Try exact first, then lower-case map
      if(LEGACY_TO_3[s]) return LEGACY_TO_3[s];
      if(LEGACY_TO_3[key]) return LEGACY_TO_3[key];
      return ''; // unknown -> treat as unlabeled
    }

    const els = {
      csvFile: document.getElementById('csvFile'),
      btnExportCsv: document.getElementById('btnExportCsv'),
      btnClearLabels: document.getElementById('btnClearLabels'),
      btnPrev: document.getElementById('btnPrev'),
      btnNext: document.getElementById('btnNext'),
      btnNextUnlabeled: document.getElementById('btnNextUnlabeled'),
      searchBox: document.getElementById('searchBox'),
      filterMode: document.getElementById('filterMode'),
      labelFilter: document.getElementById('labelFilter'),
      dataBody: document.getElementById('dataBody'),
      datasetName: document.getElementById('datasetName'),
      statTotal: document.getElementById('statTotal'),
      statLabeled: document.getElementById('statLabeled'),
      notif: document.getElementById('notif'),
      btnScrollTop: document.getElementById('btnScrollTop'),
      btnScrollBottom: document.getElementById('btnScrollBottom'),
      btnImportLabeled: document.getElementById('btnImportLabeled'),
      importLabeledFile: document.getElementById('importLabeledFile'),
      btnSaveNow: document.getElementById('btnSaveNow'),
      btnClearProject: document.getElementById('btnClearProject'),
      restorePrompt: document.getElementById('restorePrompt'),
      btnRestore: document.getElementById('btnRestore'),
      btnDiscard: document.getElementById('btnDiscard'),
      // Guide UI
      guideDefinitions: document.getElementById('guideDefinitions'),
      guideEditor: document.getElementById('guideEditor'),
      btnEditGuide: document.getElementById('btnEditGuide'),
      btnResetGuide: document.getElementById('btnResetGuide'),
      btnGuideSave: document.getElementById('btnGuideSave'),
      btnGuideCancel: document.getElementById('btnGuideCancel'),
      g_pos: document.getElementById('guide_pos'),
      g_neu: document.getElementById('guide_neu'),
      g_neg: document.getElementById('guide_neg'),
    };

    function notify(msg, kind='info', timeout=1800){
      els.notif.textContent = msg;
      els.notif.className = 'notif' + (kind === 'error' ? ' error' : '');
      els.notif.style.display = 'block';
      if(timeout) setTimeout(()=> els.notif.style.display='none', timeout);
    }
    function djb2(str){ let h=5381; for(let i=0;i<str.length;i++){ h=((h<<5)+h)+str.charCodeAt(i); h|=0; } return (h>>>0).toString(36); }
    function buildDatasetKey(filename, ids){ const sig = filename+'|'+ids.slice(0,200).join('|')+'|'+ids.length; return 'sentiment_3labels::'+djb2(sig); }
    function saveLabels(){ if(!datasetKey) return; const map = Object.fromEntries(rows.map(r=>[String(r.doc_id), r.label || ''])); localStorage.setItem(datasetKey, JSON.stringify(map)); }
    function tryRestoreLabels(){ if(!datasetKey) return 0; const txt = localStorage.getItem(datasetKey); if(!txt) return 0; try{ const map=JSON.parse(txt); let n=0; rows.forEach(r=>{ const k=String(r.doc_id); if(map[k]){ r.label=normalizeLabel(map[k]); n++; } }); return n; }catch(e){ return 0; } }

    function detectTextField(fields){
      const candidates=['Main_Text','raw_text','text','review_text','MainText','RawText'];
      for(const c of candidates){ if(fields.includes(c)) return c; }
      const lower=fields.map(f=>f.toLowerCase());
      for(const o of ['main_text','raw_text','text']){ const i=lower.indexOf(o); if(i>=0) return fields[i]; }
      return null;
    }

    function updateStats(){ els.statTotal.textContent=rows.length; els.statLabeled.textContent=rows.filter(r=>r.label && r.label.trim()).length; }

    function applyFilters(){
      const q=(els.searchBox.value||'').trim().toLowerCase();
      const mode=(els.filterMode && els.filterMode.value)||'all';
      const labf=(els.labelFilter && els.labelFilter.value)||'any';
      filteredIdx=[];
      for(let i=0;i<rows.length;i++){
        const r=rows[i];
        const hay=(String(r.doc_id)+' '+String(r.text||'')).toLowerCase();
        const passQ=q? hay.includes(q): true;
        let passF=true;
        if(mode==='unlabeled') passF=!(r.label && r.label.trim());
        else if(mode==='labeled') passF=!!(r.label && r.label.trim());
        let passLab=true;
        if(mode!=='unlabeled'){
          if(labf!=='any') passLab = r.label===labf;
        } else {
          passLab = true; // ignore label filter when unlabeled mode
        }
        if(passQ && passF && passLab) filteredIdx.push(i);
      }
      if(filteredIdx.length===0) focusIdx=-1; else if(focusIdx<0 || focusIdx>=filteredIdx.length) focusIdx=0;
    }

    function renderTable(){
      applyFilters();
      const frag=document.createDocumentFragment();
      for(const [k, idx] of filteredIdx.entries()){
        const r=rows[idx];
        const tr=document.createElement('tr'); tr.dataset.idx=String(idx);
        if(k===focusIdx) tr.classList.add('row-focus');
        const tdId=document.createElement('td'); tdId.textContent=String(r.doc_id); tdId.className='small text-muted'; tr.appendChild(tdId);
        const tdText=document.createElement('td'); tdText.textContent=String(r.text||'').trim(); tr.appendChild(tdText);
        const tdLabel=document.createElement('td');
        const sel=document.createElement('select'); sel.className='form-select form-select-sm label-select'; sel.dataset.idx=String(idx);
        const empty=document.createElement('option'); empty.value=''; empty.textContent='— Select sentiment —'; sel.appendChild(empty);
        for(let i=0;i<LABELS.length;i++){ const opt=document.createElement('option'); opt.value=LABELS[i]; opt.textContent=`${i+1}. ${LABELS[i]}`; sel.appendChild(opt); }
        sel.value=normalizeLabel(r.label) || '';
        tdLabel.appendChild(sel); tr.appendChild(tdLabel);
        frag.appendChild(tr);
      }
      els.dataBody.innerHTML=''; els.dataBody.appendChild(frag);
      const hasData=rows.length>0; els.btnExportCsv.disabled=!hasData; els.btnClearLabels.disabled=!hasData; els.btnPrev.disabled=!hasData; els.btnNext.disabled=!hasData; els.btnNextUnlabeled.disabled=!hasData; els.btnImportLabeled.disabled=!hasData; if(els.btnClearProject) els.btnClearProject.disabled=!hasData; updateStats();
    }

    function focusRowByFilteredIndex(k){ if(k<0 || k>=filteredIdx.length) return; focusIdx=k; document.querySelectorAll('#dataBody tr').forEach((tr,i)=>{ if(i===focusIdx) tr.classList.add('row-focus'); else tr.classList.remove('row-focus'); }); const tr=document.querySelector('#dataBody tr:nth-child('+(focusIdx+1)+')'); if(tr) tr.scrollIntoView({block:'nearest'}); }
    function labelFocusedRowByIndex(labelIndex){ if(focusIdx<0 || focusIdx>=filteredIdx.length) return; const realIdx=filteredIdx[focusIdx]; rows[realIdx].label=LABELS[labelIndex]; const rowEl=document.querySelector('#dataBody tr:nth-child('+(focusIdx+1)+') select'); if(rowEl) rowEl.value=LABELS[labelIndex]; saveLabels(); updateStats(); }
    function nextRow(){ if(focusIdx>=0 && focusIdx<filteredIdx.length-1) focusRowByFilteredIndex(focusIdx+1); }
    function prevRow(){ if(focusIdx>0) focusRowByFilteredIndex(focusIdx-1); }
    function nextUnlabeled(){ if(filteredIdx.length===0) return; const start=Math.max(0, focusIdx); for(let k=start;k<filteredIdx.length;k++){ const r=rows[filteredIdx[k]]; if(!r.label || !r.label.trim()){ focusRowByFilteredIndex(k); return; } } for(let k=0;k<start;k++){ const r=rows[filteredIdx[k]]; if(!r.label || !r.label.trim()){ focusRowByFilteredIndex(k); return; } } notify('No unlabeled rows in current filter'); }

    // IndexedDB helpers
    function openDB(){
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = function(evt){ const db = evt.target.result; if(!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE); };
        req.onsuccess = evt => { db = evt.target.result; resolve(db); };
        req.onerror = evt => reject(evt.target.error);
      });
    }
    function saveProjectToDB(){
      if(!db) return Promise.resolve();
      return new Promise((resolve,reject)=>{
        try{
          const tx = db.transaction([DB_STORE], 'readwrite');
          const store = tx.objectStore(DB_STORE);
          const payload = { fileName, textFieldName, rows, labelGuide, savedAt: new Date().toISOString() };
          const req = store.put(payload, DB_KEY);
          req.onsuccess = ()=> resolve();
          req.onerror = e => reject(e.target.error);
        }catch(e){ reject(e); }
      });
    }
    function loadProjectFromDB(){
      if(!db) return Promise.resolve(null);
      return new Promise((resolve,reject)=>{
        try{
          const tx = db.transaction([DB_STORE], 'readonly');
          const store = tx.objectStore(DB_STORE);
          const req = store.get(DB_KEY);
          req.onsuccess = ()=> resolve(req.result || null);
          req.onerror = e => reject(e.target.error);
        }catch(e){ reject(e); }
      });
    }
    function clearProjectFromDB(){
      if(!db) return Promise.resolve();
      return new Promise((resolve,reject)=>{
        try{
          const tx = db.transaction([DB_STORE], 'readwrite');
          const store = tx.objectStore(DB_STORE);
          const req = store.delete(DB_KEY);
          req.onsuccess = ()=> resolve();
          req.onerror = e => reject(e.target.error);
        }catch(e){ reject(e); }
      });
    }
    function scheduleAutoSave(){ if(autoSaveTimer) clearTimeout(autoSaveTimer); autoSaveTimer = setTimeout(()=>{ saveProjectToDB().catch(()=>{}); }, AUTO_SAVE_DELAY); }
    function setLoadedUIState(isLoaded){ if(els.btnClearProject) els.btnClearProject.disabled = !isLoaded; if(els.btnSaveNow) els.btnSaveNow.disabled = !isLoaded; }

    // ===== Guide rendering and editing =====
    function renderGuide(){
      if(!els.guideDefinitions) return;
      const order = LABELS;
      const ul = document.createElement('ul'); ul.className = 'mb-2';
      order.forEach(lab=>{
        const li = document.createElement('li');
        const strong = document.createElement('strong'); strong.textContent = lab;
        li.appendChild(strong); li.appendChild(document.createTextNode(' — ' + (labelGuide[lab] || '')));
        ul.appendChild(li);
      });
      els.guideDefinitions.innerHTML=''; els.guideDefinitions.appendChild(ul);
    }
    function openGuideEditor(){ if(!els.guideEditor) return; els.guideEditor.classList.remove('d-none');
      els.g_pos.value = labelGuide['Positive'] || '';
      els.g_neu.value = labelGuide['Neutral'] || '';
      els.g_neg.value = labelGuide['Negative'] || '';
    }
    function closeGuideEditor(){ if(!els.guideEditor) return; els.guideEditor.classList.add('d-none'); }
    function ensureGuideKeys(){ LABELS.forEach(k=>{ if(!(k in labelGuide)) labelGuide[k] = DEFAULT_GUIDE[k] || ''; }); }
    function resetGuideToDefaults(){ labelGuide = { ...DEFAULT_GUIDE }; ensureGuideKeys(); renderGuide(); scheduleAutoSave(); }
    if(els.btnEditGuide) els.btnEditGuide.addEventListener('click', ()=> openGuideEditor());
    if(els.btnGuideCancel) els.btnGuideCancel.addEventListener('click', ()=> closeGuideEditor());
    if(els.btnGuideSave) els.btnGuideSave.addEventListener('click', ()=>{
      labelGuide['Positive'] = els.g_pos.value.trim();
      labelGuide['Neutral'] = els.g_neu.value.trim();
      labelGuide['Negative'] = els.g_neg.value.trim();
      renderGuide();
      closeGuideEditor();
      const guidePanel = document.querySelector('details');
      if(guidePanel){ guidePanel.open = true; }
      if(els.guideDefinitions){ els.guideDefinitions.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
      scheduleAutoSave();
      notify('Guide updated');
    });
    if(els.btnResetGuide) els.btnResetGuide.addEventListener('click', ()=>{ if(confirm('Reset guide definitions to defaults?')) resetGuideToDefaults(); });

    // Render guide on startup
    renderGuide();

    // Import CSV
    els.csvFile.addEventListener('change', (e)=>{
      const file=e.target.files && e.target.files[0]; if(!file) return;
      Papa.parse(file, { header:true, skipEmptyLines:'greedy', complete: function(res){
        const data=res.data||[]; const fields=res.meta && res.meta.fields? res.meta.fields: Object.keys(data[0]||{});
        const textField=detectTextField(fields);
        if(!fields.includes('doc_id') || !textField){ notify('CSV must include doc_id and Main_Text/raw_text columns','error', 3500); return; }
        textFieldName=textField; fileName = file.name;
        // Detect label & source columns
        const hasHumanLabel = fields.includes('human_label');
        const hasSentimentLabel = fields.includes('sentiment_label');
        labelColumnName = hasHumanLabel ? 'human_label' : (hasSentimentLabel ? 'sentiment_label' : 'sentiment_label');
        hasSourceColumn = fields.includes('source');

        rows=data.map((row,i)=>({
          doc_id: row['doc_id'] ?? (row['id'] ?? (i+1)),
          text: row[textFieldName] ?? '',
          label: normalizeLabel(row[labelColumnName] || ''),
          ...(hasSourceColumn ? { source: row['source'] ?? '' } : {})
        }));
        datasetKey=buildDatasetKey(file.name, rows.map(r=>String(r.doc_id)));
        const restored=tryRestoreLabels();
        els.datasetName.textContent=file.name + (restored? ` — restored ${restored} labels`: '');
        if(els.filterMode) els.filterMode.value='all';
        if(els.labelFilter) els.labelFilter.value='any';
        focusIdx=0; renderTable(); notify('CSV loaded');
        renderGuide();
        saveProjectToDB().then(()=> setLoadedUIState(true)).catch(()=>{});
      }, error: function(){ notify('Failed to parse CSV','error'); }});
    });

    // Edit label via select
    els.dataBody.addEventListener('change', (e)=>{
      const t=e.target; if(t && t.matches('select.label-select')){
        const idx=Number(t.dataset.idx);
        rows[idx].label=normalizeLabel(t.value) || '';
        saveLabels(); updateStats();
        saveProjectToDB().catch(()=>{});
        if(els.filterMode && els.filterMode.value === 'unlabeled'){
          renderTable();
          nextUnlabeled();
        } else {
          renderTable(); // refresh for label filter effect
        }
      }
    });

    // Row focus via click
    els.dataBody.addEventListener('click', (e)=>{ const tr=e.target.closest('tr'); if(!tr) return; const all=Array.from(els.dataBody.querySelectorAll('tr')); const k=all.indexOf(tr); focusRowByFilteredIndex(k); });

    // Navigation
    els.btnPrev.addEventListener('click', prevRow);
    els.btnNext.addEventListener('click', nextRow);
    els.btnNextUnlabeled.addEventListener('click', nextUnlabeled);

    // Export CSV
    els.btnExportCsv.addEventListener('click', ()=>{
      if(rows.length===0) return;
      const labelCol = labelColumnName || 'sentiment_label';
      const header = ['doc_id', textFieldName].concat(hasSourceColumn? ['source'] : []).concat([labelCol]);
      const data=rows.map(r=>({
        'doc_id': r.doc_id,
        [textFieldName]: r.text,
        ...(hasSourceColumn ? { 'source': r.source ?? '' } : {}),
        [labelCol]: r.label || ''
      }));
      const csv=Papa.unparse({ fields: header, data: data.map(row=> header.map(h=> row[h])) });
      const blob=new Blob([csv], { type:'text/csv;charset=utf-8;' }); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='sentiment_labeled_3labels.csv'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); notify('Exported labeled CSV');
      setTimeout(async ()=>{
        try{
          if(confirm('Export complete. Clear saved project from this browser?')){
            await clearProjectFromDB(); setLoadedUIState(false); notify('Project cleared from browser storage');
          }
        }catch(_){ }
      }, 200);
    });

    // Manual Save Now
    if(els.btnSaveNow){ els.btnSaveNow.addEventListener('click', async ()=>{ try{ await saveProjectToDB(); notify('Saved to browser storage'); }catch(e){ notify('Save failed','error'); } }); }

    // Filter & scroll controls
    els.searchBox.addEventListener('input', ()=>{ renderTable(); });
    if(els.filterMode) els.filterMode.addEventListener('change', ()=>{ renderTable(); });
    if(els.labelFilter) els.labelFilter.addEventListener('change', ()=>{ renderTable(); });
    els.btnScrollTop.addEventListener('click', ()=>{ const wrap=document.querySelector('.table-responsive'); if(wrap) wrap.scrollTo({top:0, behavior:'smooth'}); });
    els.btnScrollBottom.addEventListener('click', ()=>{ const wrap=document.querySelector('.table-responsive'); if(wrap) wrap.scrollTo({top:999999, behavior:'smooth'}); });

    // Import labeled CSV (merge or load)
    els.btnImportLabeled.addEventListener('click', ()=>{ els.importLabeledFile.click(); });
    els.importLabeledFile.addEventListener('change', (e)=>{
      const file=e.target.files && e.target.files[0]; if(!file) return;
      Papa.parse(file, { header:true, skipEmptyLines:'greedy', complete: function(res){
        const data=res.data||[]; if(!data.length){ notify('No rows found in labeled CSV','error'); return; }
        const fields=res.meta && res.meta.fields? res.meta.fields: Object.keys(data[0]||{});
        const textField=detectTextField(fields);
        const hasHuman=fields.includes('human_label');
        const hasSent=fields.includes('sentiment_label');
        const labField = hasHuman ? 'human_label' : (hasSent ? 'sentiment_label' : null);
        if(!fields.includes('doc_id') || !labField){ notify('Labeled CSV must include doc_id and human_label/sentiment_label','error', 4000); return; }
        const hasSrc=fields.includes('source');
        let updated=0, skipped=0;
        if(rows.length){
          const byId=new Map(rows.map((r,i)=>[String(r.doc_id), i]));
          data.forEach(row=>{ const id=String(row['doc_id']); if(byId.has(id)){ const idx=byId.get(id); rows[idx].label=normalizeLabel(row[labField] || ''); if(textField && row[textField] && !rows[idx].text){ rows[idx].text=row[textField]; } if(hasSrc && hasSourceColumn){ if(!rows[idx].source) rows[idx].source = row['source'] ?? rows[idx].source; } updated++; } else { skipped++; } });
          saveLabels(); updateStats(); renderTable(); scheduleAutoSave(); notify(`Imported labels: updated ${updated}` + (skipped? `, skipped ${skipped}`: ''));
        } else {
          if(!textField){ notify('Cannot load labeled CSV as dataset: missing text column','error'); return; }
          textFieldName=textField; labelColumnName = labField; hasSourceColumn = fields.includes('source');
          rows=data.map((row,i)=>({ doc_id: row['doc_id'] ?? (row['id'] ?? (i+1)), text: row[textFieldName] ?? '', label: normalizeLabel(row[labField] || ''), ...(hasSourceColumn ? { source: row['source'] ?? '' } : {}) }));
          datasetKey=buildDatasetKey(file.name, rows.map(r=>String(r.doc_id)));
          els.datasetName.textContent=file.name + ' (labeled import)';
          fileName = file.name; focusIdx=0; renderTable(); renderGuide(); saveProjectToDB().then(()=> setLoadedUIState(true)).catch(()=>{}); notify('Loaded labeled dataset');
        }
        e.target.value='';
      }, error: function(){ notify('Failed to parse labeled CSV','error'); }});
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      if(rows.length===0) return; const tag=(e.target && e.target.tagName || '').toLowerCase(); if(tag==='input' || tag==='select' || tag==='textarea') return;
      if(e.key==='ArrowDown'){ e.preventDefault(); nextRow(); return; }
      if(e.key==='ArrowUp'){ e.preventDefault(); prevRow(); return; }
      if(e.key==='Enter'){ e.preventDefault(); nextRow(); return; }
      if(e.key==='u' || e.key==='U'){
        e.preventDefault();
        if(focusIdx>=0){
          const realIdx=filteredIdx[focusIdx];
          rows[realIdx].label='';
          const sel=document.querySelector('#dataBody tr:nth-child('+(focusIdx+1)+') select'); if(sel) sel.value='';
          saveLabels(); updateStats(); saveProjectToDB().catch(()=>{});
          if(els.filterMode && els.filterMode.value === 'labeled'){
            renderTable();
            nextRow();
          }
        }
        return;
      }
      const num=Number(e.key);
      if(num>=1 && num<=3){
        e.preventDefault();
        labelFocusedRowByIndex(num-1);
        saveProjectToDB().catch(()=>{});
        if(els.filterMode && els.filterMode.value === 'unlabeled'){
          renderTable();
          nextUnlabeled();
        } else {
          nextRow();
        }
      }
    });

    // Clear Labels
    if(els.btnClearLabels){ els.btnClearLabels.addEventListener('click', ()=>{
      if(rows.length===0) return; if(!confirm('Clear all labels?')) return;
      rows.forEach(r=> r.label=''); saveLabels(); updateStats(); renderTable(); scheduleAutoSave();
    }); }

    // Clear Project button
    if(els.btnClearProject){ els.btnClearProject.addEventListener('click', async ()=>{ if(confirm('Clear current project from browser storage and reset the session?')){ await clearProjectFromDB(); rows=[]; textFieldName=null; datasetKey=null; fileName=''; filteredIdx=[]; focusIdx=-1; els.dataBody.innerHTML=''; els.datasetName.textContent=''; updateStats(); setLoadedUIState(false); notify('Project cleared'); } }); }

    // Startup: open DB and ask to restore
    (async function init(){
      try{
        await openDB();
        const proj = await loadProjectFromDB();
        if(proj && proj.rows && proj.rows.length){
          if(els.restorePrompt) els.restorePrompt.classList.remove('d-none');
          if(els.btnRestore) els.btnRestore.onclick = ()=>{
            rows = (proj.rows || []).map(r=> ({...r, label: normalizeLabel(r.label)})); textFieldName = proj.textFieldName; fileName = proj.fileName || '';
            if(proj.labelGuide) labelGuide = proj.labelGuide;
            ensureGuideKeys();
            els.datasetName.textContent = fileName ? `${fileName} — restored session` : 'restored session';
            if(els.restorePrompt) els.restorePrompt.classList.add('d-none');
            renderTable(); renderGuide(); notify('Session restored'); setLoadedUIState(true);
          };
          if(els.btnDiscard) els.btnDiscard.onclick = async ()=>{
            await clearProjectFromDB(); if(els.restorePrompt) els.restorePrompt.classList.add('d-none'); setLoadedUIState(false); notify('Previous session discarded');
          };
        }
      }catch(e){ console.error('DB init error', e); }
    })();
  </script>
</body>
</html>
